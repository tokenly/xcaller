// Generated by CoffeeScript 1.10.0

/*
 *
 * Calls notifications to subscribed clients
 *
 */

(function() {
  var BUSY_REPORT_INTERVAL_TIME, CLIENT_TIMEOUT, DEBUG, EventEmitter, JOB_LOG_FILENAME, MAX_QUEUE_SIZE, MAX_RETRIES, MAX_SHUTDOWN_DELAY, NOTIFICATIONS_OUT_TUBE, NOTIFICATIONS_RETURN_TUBE, SILLY, VERSION, Worker, beanstalkHost, beanstalkPort, busyIntervalRef, createWorkers, figlet, getNumberOfWorkersBusy, getNumberOfWorkersRunning, gracefulShutdown, handleClosedWorker, logger, restartWorker, runAllWorkers, runBusyReport, running, startWorker, startWorkers, stopAllWorkers, translateLevel, winston, workerEvents, workers;

  beanstalkHost = process.env.BEANSTALK_HOST || '127.0.0.1';

  beanstalkPort = process.env.BEANSTALK_PORT || 11300;

  MAX_RETRIES = process.env.MAX_RETRIES || 30;

  CLIENT_TIMEOUT = process.env.CLIENT_TIMEOUT || 10000;

  MAX_QUEUE_SIZE = process.env.MAX_QUEUE_SIZE || 5;

  DEBUG = !!(process.env.DEBUG || false);

  SILLY = !!(process.env.SILLY || false);

  NOTIFICATIONS_OUT_TUBE = process.env.NOTIFICATIONS_OUT_TUBE || 'notifications_out';

  NOTIFICATIONS_RETURN_TUBE = process.env.NOTIFICATIONS_RETURN_TUBE || 'notifications_return';

  JOB_LOG_FILENAME = process.env.JOB_LOG_FILENAME || null;

  VERSION = '0.3.0';

  figlet = require('figlet');

  winston = require('winston');

  Worker = require('./lib/worker');

  EventEmitter = require('events').EventEmitter;

  MAX_SHUTDOWN_DELAY = CLIENT_TIMEOUT + 1000;

  logger = new winston.Logger({
    transports: [],
    exitOnError: false
  });

  logger.add(winston.transports.Console, {
    handleExceptions: true,
    timestamp: function() {
      return new Date().toString();
    },
    formatter: function(options) {
      return ("[" + (options.timestamp()) + "] " + (options.level.toUpperCase()) + " ") + ("" + (void 0 !== options.message ? options.message + ' ' : '')) + (options.meta && Object.keys(options.meta).length ? JSON.stringify(options.meta) : '');
    },
    level: SILLY ? 'silly' : DEBUG ? 'debug' : 'info'
  });

  if (JOB_LOG_FILENAME) {
    translateLevel = function(levelString) {
      var map;
      map = {
        silly: 50,
        debug: 100,
        verbose: 150,
        info: 200,
        warn: 300,
        error: 400,
        critical: 500,
        alert: 550,
        emergency: 600
      };
      if (map[levelString] != null) {
        return map[levelString];
      }
      return 0;
    };
    logger.add(winston.transports.File, {
      filename: JOB_LOG_FILENAME,
      level: 'debug',
      json: false,
      timestamp: function() {
        return new Date().toISOString();
      },
      formatter: function(options) {
        var jsonData;
        jsonData = JSON.parse(JSON.stringify(options.meta));
        jsonData.level = translateLevel(options.level);
        jsonData.timestamp = options.timestamp();
        jsonData.message = options.message;
        return JSON.stringify(jsonData);
      }
    });
  }

  running = false;

  workerEvents = new EventEmitter();

  workers = [];

  createWorkers = function() {
    var i, j, ref, results, worker;
    results = [];
    for (i = j = 0, ref = MAX_QUEUE_SIZE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      logger.silly("creating worker " + i);
      worker = Worker.buildWorker({
        workerId: i,
        beanstalkHost: beanstalkHost,
        beanstalkPort: beanstalkPort,
        outTube: NOTIFICATIONS_OUT_TUBE,
        returnTube: NOTIFICATIONS_RETURN_TUBE,
        clientTimeout: CLIENT_TIMEOUT,
        maxRetries: MAX_RETRIES,
        logger: logger
      });
      worker.on('closed', function(closedWorkerId) {
        logger.silly("worker closed", {
          id: closedWorkerId
        });
        return handleClosedWorker(closedWorkerId);
      });
      results.push(workers.push(worker));
    }
    return results;
  };

  handleClosedWorker = function(i) {
    if (running) {
      logger.silly("will restart closed worker " + i);
      return setTimeout(function() {
        logger.silly("restarting closed worker " + i);
        return restartWorker(i);
      }, 5000);
    }
  };

  restartWorker = function(i) {
    if (running) {
      workers[i].run();
    }
  };

  startWorker = function(i) {
    logger.silly("start worker " + i);
    workers[i].run();
  };

  startWorkers = function() {
    var i, j, ref;
    for (i = j = 0, ref = MAX_QUEUE_SIZE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (running) {
        startWorker(i);
      }
    }
  };

  runAllWorkers = function() {
    running = true;
    startWorkers();
  };

  stopAllWorkers = function() {
    var i, j, ref;
    running = false;
    for (i = j = 0, ref = MAX_QUEUE_SIZE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      workers[i].stop();
    }
  };

  getNumberOfWorkersRunning = function() {
    var count, i, j, ref;
    count = 0;
    for (i = j = 0, ref = MAX_QUEUE_SIZE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (workers[i].running) {
        ++count;
      }
    }
    return count;
  };

  getNumberOfWorkersBusy = function() {
    var count, i, j, ref;
    count = 0;
    for (i = j = 0, ref = MAX_QUEUE_SIZE; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (workers[i].busy) {
        ++count;
      }
    }
    return count;
  };

  gracefulShutdown = function(callback) {
    var intervalReference, runShutdown, startTimestamp;
    startTimestamp = new Date().getTime();
    if (DEBUG) {
      console.log("[" + (new Date().toString()) + "] begin shutdown");
    }
    stopAllWorkers();
    intervalReference = null;
    runShutdown = function() {
      var numberOfWorkersRunning;
      numberOfWorkersRunning = getNumberOfWorkersRunning();
      if (numberOfWorkersRunning === 0 || (new Date().getTime() - startTimestamp >= MAX_SHUTDOWN_DELAY)) {
        if (numberOfWorkersRunning > 0) {
          if (DEBUG) {
            console.log("[" + (new Date().toString()) + "] Gave up waiting on " + numberOfWorkersRunning + " workers(s)");
          }
        }
        if (DEBUG) {
          console.log("[" + (new Date().toString()) + "] shutdown complete");
        }
        if (intervalReference != null) {
          clearInterval(intervalReference);
        }
        if (typeof busyIntervalRef !== "undefined" && busyIntervalRef !== null) {
          clearInterval(busyIntervalRef);
        }
        callback();
      } else {
        if (DEBUG) {
          console.log("[" + (new Date().toString()) + "] waiting on " + numberOfWorkersRunning + " worker(s)");
        }
      }
    };
    intervalReference = setInterval(runShutdown, 350);
    runShutdown();
  };

  process.on("SIGTERM", function() {
    if (DEBUG) {
      console.log("[" + (new Date().toString()) + "] caught SIGTERM");
    }
    return gracefulShutdown(function() {
      logger.debug('end server', {
        name: 'lifecycle.stop',
        signal: 'SiGTERM'
      });
      process.exit(0);
    });
  });

  process.on("SIGINT", function() {
    if (DEBUG) {
      console.log("[" + (new Date().toString()) + "] caught SIGINT");
    }
    gracefulShutdown(function() {
      logger.debug('end server', {
        name: 'lifecycle.stop',
        signal: 'SIGINT'
      });
      process.exit(0);
    });
  });

  runBusyReport = function() {
    var numberOfWorkersRunning;
    numberOfWorkersRunning = getNumberOfWorkersBusy();
    logger.info("Using " + numberOfWorkersRunning + " of " + MAX_QUEUE_SIZE + " workers", {
      name: "usageReport",
      used: numberOfWorkersRunning,
      max: MAX_QUEUE_SIZE
    });
  };

  BUSY_REPORT_INTERVAL_TIME = 30;

  busyIntervalRef = setInterval(runBusyReport, BUSY_REPORT_INTERVAL_TIME * 1000);

  figlet.text("Tokenly XCaller", 'Slant', function(err, data) {
    process.stdout.write(data + "\n\nVersion " + VERSION + "\nconnecting to beanstalkd at " + beanstalkHost + ":" + beanstalkPort + "\n\n");
  });

  setTimeout(function() {
    logger.debug('start server', {
      name: 'lifecycle.start'
    });
    createWorkers();
    return runAllWorkers();
  }, 10);

}).call(this);
